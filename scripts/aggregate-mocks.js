/**
 * Aggregate Mock JSON Files
 * 
 * Reads all JSON files from mocks/ directory and creates a single mocks.json
 * with lightweight stubs (removes responseBody and responseHeaders for on-demand loading)
 */

const fs = require('fs');
const path = require('path');

// Function to recursively read all JSON files
function getAllJsonFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);
  
  list.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat && stat.isDirectory()) {
      results = results.concat(getAllJsonFiles(filePath));
    } else if (file.endsWith('.json')) {
      results.push(filePath);
    }
  });
  
  return results;
}

/**
 * Aggregate mocks from a directory
 * 
 * @param {string} mocksDir - Path to mocks directory
 * @returns {object} - Aggregated mocks object
 */
function aggregateMocks(mocksDir) {
  // Read all mock files
  const mockFiles = getAllJsonFiles(mocksDir);
  const mocks = [];
  const errors = [];
  
  mockFiles.forEach(filePath => {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const mockData = JSON.parse(content);
      
      // Add metadata
      const relativePath = path.relative(mocksDir, filePath);
      
      // Remove large response fields - they're loaded from EDS when needed
      // Individual JSON files remain complete with full response data
      const lightweightMock = {
        ...mockData,  // Copy all fields from original mock
        responseHeaders: {},  // Remove - will be loaded from EDS
        responseBody: {},     // Remove - will be loaded from EDS
        _metadata: {
          sourceFile: relativePath,
          lastModified: fs.statSync(filePath).mtime.toISOString()
        }
      };
      
      mocks.push(lightweightMock);
      
      console.log(`‚úì Loaded: ${relativePath}`);
    } catch (err) {
      const relativePath = path.relative(mocksDir, filePath);
      console.error(`‚úó Error loading ${relativePath}:`, err.message);
      errors.push({ file: relativePath, error: err.message });
    }
  });
  
  // Create aggregated output
  const output = {
    _comment: "AUTO-GENERATED FILE - DO NOT EDIT MANUALLY! Edit files in mocks/ folder instead. This file is generated by .github/workflows/aggregate-mocks.yml",
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    totalMocks: mocks.length,
    mocks: mocks
  };
  
  return { output, errors };
}

/**
 * Main execution when run directly
 */
function main() {
  const mocksDir = path.join(process.cwd(), 'mocks');
  const outputFile = path.join(process.cwd(), 'mocks.json');
  
  console.log('üì¶ Aggregating mock files...\n');
  
  const { output, errors } = aggregateMocks(mocksDir);
  
  // Write to mocks.json
  fs.writeFileSync(outputFile, JSON.stringify(output, null, 2));
  
  // Calculate and log size savings
  const mocksJsonSize = fs.statSync(outputFile).size;
  const mocksJsonSizeMB = (mocksJsonSize / 1024 / 1024).toFixed(2);
  
  console.log(`\n‚úÖ Created mocks.json with ${output.totalMocks} mock(s)`);
  console.log(`üìä File size: ${mocksJsonSizeMB} MB`);
  
  if (errors.length > 0) {
    console.error(`\n‚ö†Ô∏è  ${errors.length} file(s) failed to load`);
    process.exit(1);
  }
}

// Export for testing
module.exports = {
  aggregateMocks,
  getAllJsonFiles
};

// Run if executed directly
if (require.main === module) {
  main();
}

